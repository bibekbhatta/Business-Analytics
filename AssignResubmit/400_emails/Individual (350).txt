that highlight the rapid pace of development of awesome sauce java... have a nice day â˜º awesome sauce java is an implementation of interpreted java that exposes the majority of the java jdk. the compiler is designed and partially implemented to make seamless load of compiled code quiet   without restart. much of the java (8. se jdk) language is available and working as is. testing is progressing and many java methods run against their instance classes without fail. there are many classes that need bridge classes built to make elements available, such as graphics classes, javafx, listeners and threads. the parser is stable, but immature. it's going to take a 2 5 days to make rock solid. the eval code likewise needs a 2 3 days of review. many of the applications are works in progress, but will take a few weeks to construct, faster if the awesome sauce builder (graphical interface builder) is as fast as the prototype. the majority of the three months is going to be focused on building bridge classes and testing: building test code and test applications. building bridge classes provides the mechanism to facilitate method dispatch from internal implementation methods to awesome sauce java interpreted code. many of the core apps and components are designed. the compiler is designed and ready to build, as is the awesome sauce doctor (self healing code.) if it sounds like a lot of work, it is. but the language and tools make it possible to fly. the goal is to get these tools into your hands quickly, because they're hot it will take 3 months to build the first version of awesome sauce java. it might be a late beta version, but it will be feature complete, highly tested, stable, and well documented. what works will be known and documented, along with what doesn't. the release will include a suite of test code, test apps, and enough demo applications   real, working applications   to not only test the system, but provide an extensive collection of awesome sauce java code for the release. will any parts of java be missing? so far, no. but, it's hard to know if there are areas that are going to be prohibitive to make work well. awesome sauce java is proving itself to be incredibly fast and dynamic, while validating that the awesome sauce java to java interfaces are stable. a lot of design effort went into making the language leverage java without modification, while improving stability. there are very few exceptions thrown that aren't caught and managed, allowing the runtime to maintain significantly better uptime than java applications. threads are always an area of concern. will it work with jdbc? yes. i had been testing the jdbc interfaces when a hard drive crash caused me to lose the code. it was working well and will get built and included for the first release. i was also exploring client server interactions via the glassfish server and will publish updates in the weekly newsletter regarding progress about these components and awesome sauce java. what other cool features should i know about? thee method calls can be localized. in fact, the goal of the system is to facilitate collaborative, real time programming and in different languages, such that code written in a first language is displayed to co collaborators in their native language as code is entered. the mechanism and locale folders for the localized entries are already in place. it's a matter of localizing method names to make it work at the code level. the editor is also going to encourage localizing as much of the display as possible. it's hoped that the combination of a license that encourages sharing, in combination with an environment that reduces linguistic barriers, will make hive programming, and more expressive applications and tools, possible. the pairing of awesome sauce builder and awesome sauce editor operating and editing an application simultaneously may make it possible for non tech and tech people to co collaborate on app design and implementation simultaneously. how these applications come together will be updated in the weekly awesome sauce newsletter. a sketch of parallel processing applications is on the pile of work to do. it starts with a dispatching application and a set of supporting apps, each of which is configured for a set of libraries/packages and assigned to a processor. what about modern features? the language is highly flexible. concepts like concurrency and parallel processing have been considered. they will be implemented in a future version of awesome sauce java as a natural extension of the language. the first version is intended to be focused on a stable java release, running on a stable java, with code that looks like, and is, standard java. it's hoped that by providing a stable, interpreted java that looks like java, more people will be likely to take a look and explore. the language internals are very clean and malleable. a subsequent version could introduce a concurrent language as an extension or second language. awesome sauce java looks like lisp, with some smalltalk. what gives? awesome sauce java includes a wealth of common lisp functions and features. it might even contain a complete implementation of common lisp at the first release, or soon after. it turns out that lisp with java provides exceptional expressive power. both languages are incorporated in their standard form to make it possible for people familiar with each to jump in and explore without having to learn a new language. but awesome sauce java is java and it exposes java in an interpreted form. the lisp part is a nice bonus, because lisp offers a lot of opportunity to do things like ai, rules, runtime & realtime editing of applications, functions, methods, and classes. plus, it stabilizes java to the point where java mostly doesn't crash. hopefully, the first release won't crash at all. point is, awesome sauce java is java, because java is stable and has a great release format, but lisp is a super secret bonus that can be ignored by java programmers until they start to learn some of the idioms and realize it's a powerful language that plays nice with java. the combination of the two languages is where the magic happens, becoming a new language of its own. applications and tools the following tools are already works in process and will be released with awesome sauce java 1.0. awesome sauce interface builder quickly lay out working applications. reattach to running applications and make modifications without having to stop and start. generate code for stand alone java applications. awesome sauce editor edit and run awesome sauce java code from within an environment made especially for the dynamic performance of the language. attach to running applications, execute commands, and start processes. awesome sauce terminal connect from your favorite editor to the awesome sauce terminal and run commands, start processes, and develop applications. task manager & demo apps track tasks and activities in a full featured awesome sauce java application built for making it fast to keep track of information and things to do. plus, awesome sauce java will be released with a set of demo applications, sample code, test suites, and any other widgets we can put in the package. awesome sauce friends there are a gazillion third party java libraries, is there any chance they can be included with, or imported into, awesome sauce java? yes. it's possible that some of the major third party libraries, from amazon, google, apache, and more, will be included with the first release of awesome sauce java. there's no technical reason not to include them. the only limiting factor is testing time. the first release has to be functional, stable, and tested, and that represents a lot of work. if much of it can be automated, then it'll make it easier to take a look at third party libraries and begin to work with those whose licenses are friendly to the awesome sauce license. the at least weekly awesome sauce newsletter released as often as it makes sense, full of updates, status, and news. future plans it's possible one, some, or all of the following applications and components will be in the first release, it's also possible they'll be released soon after. all who donate to the awesome sauce crowd funding campaign will be eligible to receive any or all when they're ready. awesome sauce os an editable os. runs on all os's. can be it's own os on a wide range of computer and mobile devices. hot sauce fast ui. very fast ui. built by a disabled man to simplify complexity, and wait'll you try it, it's awesome sauce with hot sauce! awesome sauce doctor self modifying, self healing code. rules based. ai. designed and early prototype built. looks pretty exciting as it makes it possible to build a suite of code for a code point/function that responds to error conditions, exceptions, or other conditions, allowing for the modification of code at runtime based on rules. could also be used for subscription, cron, update, and a wealth of code management related functions. awesome sauce shop the store for awesome sauce java applications, modules, tools, and more. awesome sauce transformers hot swappable function code, making it possible to extend the awesome sauce os and applications with new features, bug fixes, and upgrades while they're running. awesome sauce parallel modules & concurrency it's possible to configure an awesome sauce build with various java core libraries. it's hoped that by building configurable apps and modules, that a system can be constructed that enables parallel or distributed processing, where a dispatch application (or set of) sends requests to specialized application configurations assigned to cores or processors in order to improve processing power. awesome sauce java is java, so all the threading of java is available. threading is always a challenge, so the threading model and concurrency, as well as other modern features, will be explored once the first version is stable and/or released. concurrency is a complex issue. if it turns out it can be added in the first release, it will be added, but the plan is for concurrency to be considered after the first release. the following listings show code that has been run through awesome sauce java. they are hand tested classes and instances i've used to verify performance, fix bugs, and add features. // file java > (setf *files* (new file "/home/michael/jdk/src/java")) /home/michael/jdk/src/java java > (setf *all files* (list *files*)) [ljava.lang.string;@3c756e4d java > (ascend *all files* #'princ) text net rmi applet nio lang awt sql beans math util security io time java > (get name *files*) java java > (get path *files*) /home/michael/jdk/src/java java > (get total space *files*) 245058105344 java > (get usable space *files*) 208122343424 java > (is absolute *files*) true java > (is directory *files*) true java > (is hidden *files*) false java > (last modified *files*) 1506374080000 java > (length *files*) 4096 java > (list roots *files*) null java > (setf *path* (to path *files*)) /home/michael/jdk/src/java java > *path* /home/michael/jdk/src/java java > (touri *files*) file:/home/michael/jdk/src/java/ java > (exists *files*) true java > (get absolute file *files*) /home/michael/jdk/src/java java > (get parent *files*) /home/michael/jdk/src java > (get parent file *files*) /home/michael/jdk/src java > // java.lang.math java > (math.abs  21123.3023) 21123.3023 java > (math.acos  17.322)  java > (math.acos 0.55) 0.9884320889261531 java > (math.acos  0.55) 2.15316056466364 java > (math.addexact 12345 49495) 61840 java > (math.asin 1.0) 1.5707963267948966 java > (math.asin  1.0)  1.5707963267948966 java > (math.atan 1.0) 0.7853981633974483 java > (math.atan2 1.0 2.0) 0.4636476090008061 java > (math.cbrt 2.0) 1.2599210498948732 java > (math.ceil (math.cbrt 2.0)) 2.0 java > (math.copysign 123.030  1203.40)  123.03 java > (math.cos 0.2341) 0.9727235061230322 java > (math.cosh 1.073) 1.6330599023380639 java > (math.decrementexact 173994) 173993 java > (math.exp 2.737) 15.440593762844655 java > (math.expm1 2.737) 14.440593762844655 java > (math.floor (math.expm1 2.727)) 14.0 java > (math.getexponent 76.38872) 6 java > (math.hypot 4.37 8.838) 9.859368336764785 java > (math.ieeeremainder 17.440 13.994) 3.4460000000000015 java > (math.log 239923.1003) 12.388073735563474 java > (math.log10 2340023.10211) 6.369220145046624 java > (math.log1p 23400.02304) 10.060535020048237 java > (math.max 230.2340 23.230) 230.234 java > (math.min 234.03 12123.302) 234.03 java > (math.nextafter 1231.03 233224.032) 1231.0300000000002 java > (math.nextdown 23420.023) 23420.022999999997 java > (math.pow 21.23 12.23) 1.692771851356702e16 java > (math.random) 0.6284755222833167 java > (math.rint 234.0230) 234.0 java > (math.round 12.23423) 12 java > (math.scalb 2343.23 23) 1.965643792384e10 java > (math.signum 3.3040) 1.0 java > (math.sin 2.21) 0.8025710662467472 java > (math.sinh 0.388) 0.39780872051201877 java > (math.sqrt 17.9393) 4.235481082474575 java > (math.tan 1.230) 2.819815734268152 java > (math.tanh 1.2010) 0.8339593728373399 java > (math.todegrees 12.300) 704.7380880109125 java > (math.toradians 12.300) 0.21467549799530256 java > (math.ulp 2343.340) 4.547473508864641e 13 // stringbuffer java > (setf sbuff (new stringbuffer "hey my buffer!")) hey my buffer! java > (append sbuff 'a') hey my buffer!a' java > (append sbuff true) hey my buffer!a'true java > (append sbuff (math.cos 1.0)) hey my buffer!a'true0.5403023058681398 java > (append sbuff 777) hey my buffer!a'true0.5403023058681398777 java > (append sbuff (new string "my string")) hey my buffer!a'true0.5403023058681398777my string java > (capacity sbuff) 62 java > (codepointat sbuff 12) 114 java > (codepointbefore sbuff 12) 101 java > (codepointcount sbuff 1 4) 3 java > (delete sbuff 3 9) heyffer!a'true0.5403023058681398777my string java > (ensurecapacity sbuff 100) null java > (capacity sbuff) 126 java > (index of sbuff "my") 35 java > (index of sbuff "7") 32 java > (index of sbuff "7" 32) 32 java > (index of sbuff "7" 33) 33 java > (insert 7 true) null java > (insert sbuff 7 true) heyffertrue!a'true0.5403023058681398777my string // collections, just a small sampling java > (setf *zhashmap* (new hash map)) {} java > (put *zhashmap* "one" 1) null java > (put *zhashmap* "two" 2.0) null java > (put *zhashmap* 3 "a string") null java > (put *zhashmap* 'list '(1 2 3)) null java > (keyset *zhashmap*) [3, one, two, list] java > (entryset *zhashmap*) [3=a string, one=1, two=2.0, list=(1 2 3)] java > (remove *zhashmap* "one") 1 java > (size *zhashmap*) 3 java > (isempty *zhashmap*) false java > (setf *zhashset* (new hash set)) [] java > (add *zhashset* "one") true java > (add *zhashset* 2) true java > (add *zhashset* (new jframe "test")) true java > (add *zhashset* 'symbol) true java > (setf *zlinked* (new linkedlist)) [] java > (mapcar #'(lambda (v) (add *zlinked* v)) '(1 2 3 "four" "five" "six" #'test function)) (true true true true true true true) java > (ascend *zlinked* #'princ) 1 2 3 four five six #'test function java > (descend *zlinked* #'princ) ; descending iterator #'test function six five four 3 2 1 1 java > (setf *ral* (new arraylist)) [] java > (add *ral* 1) true java > (add *ral* 2) true java > (add *ral* 3) true java > (add *ral* 4) true // currency java > (setf *curr* (currency.getinstance (locale.getdefault))) usd java > (get display name *curr*) us dollar java > (get currency code *curr*) usd java > (get default fraction digits *curr*) 2 java > (get numeric code *curr*) 840 java > (get symbol *curr*) $ java > (to string *curr*) usd // doublesummarystatistics java > (setf *dbl stats* (new doublesummarystatistics)) doublesummarystatistics{count=0, sum=0.000000, min=infinity, average=0.000000, max= infinity} java > (accept *dbl stats* 1.7) null java > (mapcar #'(lambda (v) (accept *dbl stats* v)) '(1.25 1.99 2.013 0.948 1.657)) null java > (get average *dbl stats*) 1.593 java > (get count *dbl stats*) 6 java > (get max *dbl stats*) 2.013 java > (get min *dbl stats*) 0.948 java > (get sum *dbl stats*) 9.558 java > (to string *dbl stats*) doublesummarystatistics{count=6, sum=9.558000, min=0.948000, average=1.593000, max=2.013000} // package java > (setf pkgs (package.getpackages)) [ljava.lang.package;@66d2e7d9 java > (get annotations (array.get pkgs 0)) [ljava.lang.annotation.annotation;@1efbd816 java > (get implementation vendor (array.get pkgs 0)) oracle corporation java > (get implementation version (array.get pkgs 0)) 1.8.0_144 java > (get name (array.get pkgs 0)) java.applet java > (getspecificationtitle (array.get pkgs 0)) java platform api specification java > (getspecificationversion (array.get pkgs 0)) 1.8 java > (issealed (array.get pkgs 0)) false risks and challenges the risks are in the bus number: 1. the project is written by a guy, on a computer, in a room. that's the biggest risk. the language itself is actively being used and works as advertised. there is a significant amount of work to do to middleware, but one guy exposed the whole of java in an interpreted format, so the middle sauce should be okay. there may be issues with threading and synchronization, but until experiments can be performed, it looks doable, but there might be a gotcha or a hitch somewhere. learn about accountability on  Jimmy Fraud 