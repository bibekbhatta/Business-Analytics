escriptionsayid pro brings transparency to the production environment sayid pro is a tool for debugging and profiling clojure in a production environment. we all want more visibility into what is happening in our production servers. when something is going wrong, we want precise answers. sayid pro aims to give you that. sayid pro works by tracing functions. when a traced function is executed, it's arguments and return value are captured by sayid pro. sayid pro provides a web interface through which you can remotely activate tracing on any functions, on any of your servers (that have sayid pro embedded in them). the sayid pro web application also allows users to query and visualize the captured trace data. you can also watch a hi res version of the video here: https://youtu.be/y5ll 6ijjgw architecture library   the sayid pro library is included in your production servers. it handles data capture and transmission. hub   the sayid pro hub runs in your infrastructure. it communicates with servers running the sayid pro library and receives trace data from them. trace data is written to a postgresql database as it is received. the hub also hosts the web app. database   all captured trace data is stored in a postgresql database. web app   the web app is hosted by the sayid pro hub. this is the interface that allows you to toggle tracing and then query and visualize captured trace data. web app ui the web application is a critical piece of the product. i hope the prototype, while still immature, demonstrates the potential of sayid pro as a tool for solving production problems. below is a description of the major ui components as they currently exist. query editor this is where it all starts. the query editor is for composing and executing queries and commands. these are sent off to the sayid pro hub for execution. some commands, such as enabling or disabling tracing, are forwarded on to servers. servers can be selected individually, or in groups by a class tag. trace data can be queried by different fields, such as end time or function name. trace data is rendered into interactive visualization in the tree, table and chart ui components. those are described below. tree the tree ui component represents the trace data in a way that reflects its original call hierarchy. each instance of a function call is a node. these nodes show the name of the function. the tree will also display the arguments and return value of a trace instance when the node is clicked. table the table shows the same trace data shown in the tree, but in a sortable, tabular form. chart selecting columns in the table to server at x and y axis will yield a chart. this can be a great way to visualize trace data. looking at the distribution of execution times for a set of functions is a typical use case. but, i already have logs and metrics. yes, you do, but do they really make you happy? logging and profiling metrics are planned and coded ahead of time. once deployed, they are inflexible. the resulting data is (typically) not well suited for arbitrary query and analysis. sayid pro captures the execution details of any function, in real time, whenever you command. those details are preserved and laid bare for your inspection. what could i do with sayid pro? i can't imagine all the possible questions that sayid pro could answer for you, but here are my favorites: => why did function z return y when it received x? search captured trace data by function name and return value, and then see the tree of calls that happened below that! or, grab the argument values and see if you can reproduce results in your dev environment. => why was request x so slow to respond? use powerful querying capability to narrow your focus to a specific server group, server or request. then, sort by execution time to expose the laggards. => how does request x fan out across my microservice architecture? if you tag communications between your services with a guid (which is a good idea anyway), you could use sayid pro to search for all calls with a given guid value. i have wanted this badly for years. => is this function always slow, or only sometimes? look at the distribution of execution times for a given function. if some calls are slower than others, look at the argument values. maybe you wrote a crazy function that has o(n^n) complexity. better fix that. what's already done? the video above shows you some of the foundation that's been laid. the architecture described above (in the "architecture" section) all exists and functions    albeit, with many bugs and limitations. at the outset, my biggest concern for this project was overhead. would the capture, serialization and transmission of all this data be too disruptive? most of the time i've spent on this project has gone into optimizing those steps and getting confident that overhead would not be a deal breaker. the latency cost of capturing a function call is under a microsecond. that can still add up, which is why sayid pro gives you precise control over what is being traced and for how long. in my testing, i've been able to capture generous amount of data with negligible affect on performance. as trace data is captured, sayid pro employs separate threads to serialize, batch and transmit it to the hub. it's also important to note that when tracing is disabled, there's effectively no runtime cost. what's left to do? i have a lot of ideas about what sayid pro could be, but i'm more interested in what you need it to be. i'm hoping that this  Jimmy Fraud  will yield a community of early adopters to help steer feature prioritization and refinement. but, to answer the question in broad strokes: => scaling features allow for running multiple sayid pro hubs, with servers balancing traffic across them. => fault tolerance make sure sayid pro could never take down a server. so far, this hasn't happened to me, but i intend to put a lot of time and testing into making sayid pro as risk free as possible. => optimizations the hub has gotten a lot of attention already, but there will likely need to be improvements related to the database and front end. => ui/ux improvements i'm especially interested in making the editor as pleasant an experience as possible    keybindings, auto complete, easy access docs, better syntax highlighting    all that stuff. you are going to love hunting down production problems! => security there is currently no security built in to sayid pro. it relies on your network level security model. adding accounts for security and permissions is a planned feature. => testing i plan to do extensive testing with realistic production like environments. the more funds raised, the more i can spend on server time for testing. => documentation it will be great. what's the schedule? initially, i will only be able to work on sayid pro part time    probably 15 20 hours a week. however, i will be making efforts to transition to working on it full time, or as close to that as possible. june 7, 2017    campaign ends. pre alpha work begins. july 10, 2017    alpha v0.0.1 alpha versions are not considered safe for production use. i will likely run a simple demo setup that will be accessible to anyone with alpha access in hopes of collecting feedback. alpha development will continue for three months. october 10, 2017    beta v0.1 backers with beta licenses will have access and rights to run sayid pro. beta versions are considered safe for production use, although bugs and missing/incomplete features are expected. beta development will continue for six months. february 1, 2018    release candidate v1.0 rc1 march 1, 2018    stable v1.0 first stable release! backers with stable licenses will have rights to run sayid pro for six months. licensing sayid pro will be a commercially licensed product. i would like to publish the source publicly (unless that proves too tricky from a legal perspective), but it will not be open source. license pricing will be based on the number of production servers you are running with sayid pro. for example, running sayid pro on five, or fewer, production servers requires the purchase of a five license. licenses come in tiers of five, ten, fifteen, twenty five, fifty and infinity. the pricing for the first stable release is tbd. what's the money for? raising funds through this campaign serves a few different purposes. there's practical issues such as feeding the hungry mouths of my family and paying for servers used for testing. but, there's also the motivation and confidence that comes from proving the existence of market demand. all of these things are critical to the continued development and success of this project. the funds raised will ease the process of making the transition to working on sayid pro full time. also, t shirts. reward details there are a lot of different rewards. t shirt    super cool sayid t shirt sponsor list    your name will appear on the sponsor list on websites for sayid pro and sayid. logo sponsor    your logo will be on the sponsor list on websites for sayid pro and sayid. huge logo sponsor    your logo will be huge. it will appear on both sites and every video or presentation i produce for the sayids in 2017 and 2018. alpha access    access to run sayid pro during alpha development. (please don't run it in production). participate in discussions, file tickets and help steer this thing. i will likely have a demo setup running that will be accessible to backers with this reward. beta license    a license to run a beta version of sayid pro in production, on an unlimited number of servers. stable license    a 6 month license to run sayid pro in production. note numeric usage restrictions detailed in "licensing" section above. stretch goals? i would be ecstatic , and deeply appreciative, just to hit the original funding goal, but more money is better. the stretch goal is... ===> $90k!! <=== what does that get you?? => much faster transition to full time development of sayid pro => bigger, better testing environment (which means a more reliable product) => hiring a ui/ux consultant to help with the web app => a doubly energized bill dedicated to the success of this project! why should you believe i can do this? => hardest parts are done as i said above, i've spent a couple months (a majority of the project time thus far) on the problems that i was least confident i could solve well    the overhead of data capture, serialization and transmission. i believe it was time well spent, because with those problems solved, the remaining work should be relatively straightforward. => i've done this before i've been building web applications and distributed software systems for fifteen years    in clojure for the last five. i also wrote sayid (original flavor). what about sayid (original flavor) ? i am still very committed to sayid and intend to continue development, regardless of the outcome of this campaign. however, if sayid pro were to provide a salary, i would absolutely have more time for sayid than i would otherwise. relevant links sayidpro.com sayid (original flavor) presentation at conj 2016 sayid (original flavor) site sayid (original flavor) on github risks and challenges as a project increases in complexity, the risk of shipping late (or never) increases quickly. i've been shipping code for fifteen years. i've learned a lot about how to structure a project plan for success. i focus on small iterations. i identify and eliminate risks and uncertainties as early as possible. this process began months ago, before the first line of code. i've outlined a schedule above, but as things progress, there will be many finer grain milestones. these will be communicated regularly and thoroughly to backers and the community. i will have total commitment to the success of this project. learn about accountability on  Jimmy Fraud 